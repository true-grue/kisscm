### Разбор JSON для получения статистики из GitHub

Рассмотрим задачу получения сведений о git-репозиториях пользователя GitHub посредством взаимодействия по протоколу HTTP (Hypertext Transfer Protocol) с удалённым API (Application Programming Interface), возвращающим данные в формате JSON @json. Отправка запросов и разбор ответов сервера будет осуществляться при помощи утилит командной оболочки Linux. Полученные сведения о репозиториях будут включать их имена и число «звёзд», равное количеству пользователей, добавивших репозиторий в список «избранное».

Начнём с получения списка репозиториев пользователя в формате JSON. В GitHub HTTP API настроены лимиты на число запросов в час, поэтому при помощи утилиты `curl` отправим единственный HTTP-запрос к API и, воспользовавшись оператором перенаправления вывода `>`, сохраним результат в файл `repos.json`. Получим список репозиториев, владельцем которых является пользователь GitHub с именем `true-grue`:

```
~$ curl -s https://api.github.com/users/true-grue/repos > repos.json
~$ cat repos.json | head -n 5
[
  {
    "id": 207806577,
    "node_id": "MDEwOlJlcG9zaXRvcnkyMDc4MDY1Nzc=",
    "name": "algomusic",
```

Опция `-s` используется для отключения вывода диагностических сообщений утилиты `curl`. Файл `repos.json` теперь содержит массив объектов со сведениями о репозиториях пользователя GitHub `true-grue`. В вывод, ограниченный первыми 5 строками, включён идентификатор и имя репозитория `algomusic`.

Для обработки полученного массива объектов со сведениями о репозиториях воспользуемся утилитой `jq` @jq, предназначенной для преобразования строк в формате JSON и для извлечения данных из них. Утилиту `jq` версии не ниже 1.6 потребуется установить дополнительно при помощи Вашего пакетного менеджера. Начнём с извлечения объектов из массива, содержащегося в файле `repos.json`:

```bash
~$ cat repos.json | jq '.[0]' | head -n 5
{
  "id": 207806577,
  "node_id": "MDEwOlJlcG9zaXRvcnkyMDc4MDY1Nzc=",
  "name": "algomusic",
  "full_name": "true-grue/algomusic",
~$ cat repos.json | jq '.[1]' | head -n 5
{
  "id": 427108160,
  "node_id": "R_kgDOGXUnQA",
  "name": "awesome-russian-cs-books",
  "full_name": "true-grue/awesome-russian-cs-books",
```

Выражение `.[i]` в списке параметров `jq` используется для получения $i$-го элемента из массива JSON-объектов: выражение `.[0]` позволяет получить первый элемент массива, а выражение `.[1]` – второй элемент.

Теперь извлечём имена репозиториев из JSON-объектов по ключу `name`:

```bash
~$ cat repos.json | jq '.[0].name'
"algomusic"
~$ cat repos.json | jq '.[1].name'
"awesome-russian-cs-books"
```

Для извлечения нескольких значений по нескольким ключам можно воспользоваться оператором конвейера `|` внутри строки запроса `jq`. В этом случае каждое полученное значение будет размещено на новой строке:

```bash
~$ cat repos.json | jq '.[0] | (.name, .stargazers_count)'
"algomusic"
11
~$ cat repos.json | jq '.[1] | (.name, .stargazers_count)'
"awesome-russian-cs-books"
38
```

Значения из JSON, имеющие строковой тип данных, выведены в stdout с обрамляющими двойными кавычками, а числовые значения выведены без кавычек. В случае, если необходимо соединить значения полей, можно воспользоваться оператором конкатенации строк `+`, но числа при этом необходимо явно преобразовать в строки при помощи оператора `tostring`. Кроме того, подобное преобразование легко применить сразу ко всем JSON-объектам в массиве, заменив `.[0]` на `.[]`:

```bash
~$ cat repos.json | jq '.[] | (.name + " " + (.stargazers_count | tostring))' | head -n 5
"algomusic 11"
"awesome-russian-cs-books 38"
"ayumi 88"
"BytePusher 6"
"code-snippets 3"
```

Отсортируем полученный перечень репозиториев по их числу «звёзд», равному количеству добавлений репозиториев в список «избранное» пользователями GitHub. Для этого воспользуемся стандартной утилитой `sort`, предварительно заменив двойные кавычки на пустые строки утилитой `sed`:

```bash
~$ cat repos.json | jq '.[] | (.name + " " + (.stargazers_count | tostring))' | sed 's/"//g' | sort -k 2 -n -r | head -n 5
Compiler-Development 498
kispython 203
ayumi 88
kisscm 84
raddsl 83
```

Команда `s` утилиты `sed` имеет синтаксис `s/шаблон/замена/опции`, а опция `g` переключает утилиту `sed` в режим глобального поиска и замены. С опцией `g` вместо однократной замены все двойные кавычки заменятся на пустые строки. Опция `-k` утилиты `sort` позволяет указать номер колонки, по которому необходимо упорядочить строки, при этом в качестве разделителя колонок используется пробел. Опция `-n` включает численную сортировку, а опция `-r` меняет порядок сортировки на обратный.

Преобразуем результат в формат `csv`, заменив пробел на запятую при помощи утилиты `tr`, и выведем в stdout таблицу с данными:

```bash
~$ cat repos.json | jq '.[] | (.name + " " + (.stargazers_count | tostring))' | sed 's/"//g' | sort -k 2 -n -r | tr ' ' ',' | csvlook -H | head -n 7
| a                    |   b |
| -------------------- | --- |
| Compiler-Development | 498 |
| kispython            | 203 |
| ayumi                |  88 |
| kisscm               |  84 |
| raddsl               |  83 |
```

Для вывода на экран оформленной таблицы мы воспользовались утилитой `csvlook` из пакета утилит `csvkit` @csvkit. Пакет утилит `csvkit` версии не ниже 2.0.1 потребуется установить дополнительно при системного пакетного менеджера или пакетного менеджера PyPI. Опция `-H` утилиты `csvlook` позволяет использовать имена колонок по умолчанию, поскольку наш вывод в формате `csv` не содержит строки-заголовка. В качестве имён колонок в `csvlook` с опцией `-H` используются буквы английского алфавита.

Добавим строку-заголовок к выводу в формате `csv` при помощи AWK @awk:

```bash
~$ cat repos.json | jq '.[] | (.name + " " + (.stargazers_count | tostring))' | sed 's/"//g' | sort -k 2 -n -r | tr ' ' ',' | awk 'BEGIN { print "Репозиторий,Звёзд" } { print }' | csvlook | head -n 7
| Репозиторий          | Звёзд |
| -------------------- | ----- |
| Compiler-Development |   498 |
| kispython            |   203 |
| ayumi                |    88 |
| kisscm               |    84 |
| raddsl               |    83 |
```

В языке AWK инструкция в фигурных скобках, указанная после ключевого слова `BEGIN`, выполняется однократно в момент начала выполнения команды, и в результате в вывод попадает строка `Репозиторий,Звёзд`. Инструкция `print`, указанная следующей также в фигурных скобках, выполняется для каждой строки, поступившей на вход утилите `awk` через stdin.

Полученный набор команд, объединённых оператором конвейера `|`, можно упростить, возвращая несколько строк после разбора JSON утилитой `jq` и объединяя полученные пары строк в одну утилитой `xargs` со значением параметра `-n`, равным 2. В случае, если утилита `jq` вызывается с опцией необработанного вывода `-r`, нет необходимости в преобразовании типов данных функцией `tostring` и в удалении двойных кавычек – в stdout значения полей `name` и `stargazers_count` попадут как строки, не обрамлённые кавычками. Кроме того, заменять символ пробела на запятую при формировании `csv` можно прямо в программе на языке AWK, без задействования утилиты `tr`. Объединим все инструкции в один конвейер:

```bash
~$ curl -s https://api.github.com/users/true-grue/repos \
> | jq -r '.[] | (.name, .stargazers_count)' \
> | xargs -n 2 \
> | sort -nrk2 \
> | awk 'BEGIN { print "Репозиторий,Звёзд" } { print $1 "," $2 }' \
> | csvlook \
> | head -n 7
| Репозиторий          | Звёзд |
| -------------------- | ----- |
| Compiler-Development |   498 |
| kispython            |   203 |
| ayumi                |    88 |
| kisscm               |    84 |
| raddsl               |    83 |
```

В приведённом примере кода символ `\` используется для игнорирования служебного символа переноса строки `\n`. Это позволяет разбивать на несколько строк длинные команды, в которых разные утилиты объединяются в одну команду при помощи оператора конвейера `|`.

При помощи реализованного конвейера легко получить статистику по репозиториям другого пользователя, заменив имя пользователя `true-grue` в ссылке, являющейся параметром утилиты `curl`. Попробуем в таком же формате вывести сведения о репозиториях, к которым имеет доступ пользователь GitHub `worldbeater` – такой фильтр можно включить, установив параметр строки запроса `type` равным значению `member`. Переносить фрагменты команды на новую строку можно и без использования символа `\`, как в предыдущем примере – достаточно закончить строку оператором конвейера `|`:

```bash
~$ curl -s https://api.github.com/users/worldbeater/repos?type=member |
jq -r '.[] | (.name, .stargazers_count)' |
xargs -n 2 |
sort -nrk2 |
awk 'BEGIN { print "Репозиторий,Звёзд" } { print $1 "," $2 }' |
csvlook |
head -n 7
| Репозиторий           | Звёзд |
| --------------------- | ----- |
| Camelotia             |   567 |
| Citrus.Avalonia       |   565 |
| Live.Avalonia         |   409 |
| ReactiveUI.Validation |   245 |
| ReactiveMvvm          |   180 |
```

Реализованный конвейер показан на @fig:githubpipe:

```{#fig:githubpipe .pysvg caption="Конвейер для получения и вывода статистики с GitHub" width=80%}
dot('''
digraph G {
    edge [arrowsize=0.7]
    node [shape=box]
    ranksep=0.3
    rankdir=LR
    1 [label="curl", shape=circle, fixedsize=shape]
    2 [label="jq", shape=circle, style="filled,rounded"]
    3 [label="xargs", shape=circle, fixedsize=shape]
    4 [label="sort", shape=circle, fixedsize=shape]
    5 [label="awk", shape=circle, fixedsize=shape]
    6 [label="csvlook", shape=box, style="filled,rounded"]
    7 [label="head", shape=circle, fixedsize=shape]
    1 -> 2
    2 -> 3
    3 -> 4
    4 -> 5
    5 -> 6
    6 -> 7
}
''')
```

Белом цветом на @fig:githubpipe выделены стандартные утилиты командной оболочки Linux, серым цветом выделены утилиты `jq` @jq и `csvlook` @csvkit, которые были установлены отдельно при помощи пакетного менеджера.
